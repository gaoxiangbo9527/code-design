封装变化
    找出应用中可能会变化的部分，把它们独立出来或者说封装起来，不要和那些不需要变化的部分混在一起。
    这样将来只需要改动此部分，而不会影响那些不需要变化的其他部分。系统的可维护性和可扩展性会得到提高。

不要重复你自己（Don’t repeat yourself，DRY）
    重复可能是软件中一切邪恶的根源。许多原则与实践规则都是为控制和消除重复而创建的。
    尽最大的努力去避免重复的代码。重复的代码是糟糕的，因为它意味着如果你需要修改一些逻辑的话，就要修改不止一个地方。

    参考内容
        代码整洁之道：3.10
        程序员修炼之道：20 页

分离命令与查询原则
    命令 指的就是 CURD 中的 CUD ，即插入、更新和删除，它们会改变对象的状态。
    查询 指的就是 CURD 中的 R ，即读取，它不会改变对象的状态。

------------------------------------------------------------------------------------------------------------------------
以上原则既适用于面向对象，也适用于面向过程；下面的原则只适用于面向对象。
------------------------------------------------------------------------------------------------------------------------

单一责任原则（Single Responsibility Principle，SRP）
    也称 单一权责原则 。
    一个类应该只有责任 —— 被修改的理由。即要让每个类保持责任单一。

    实现方法
        将类的大函数拆分为小函数；为了减少小函数的参数，需要将参数提升为类的实体变量；类的实体变量一多，内聚性就在下降；为了保持内聚性，可以
        将部分函数以及这些函数所共享的实体变量独立出来；这样，大类就被拆分成了许多高内聚的、职责单一的类。

    参考内容
        代码整洁之道：10.2
        Head First 设计模式：339 页

开放/关闭原则（Open/Closed Principle，OCP）
    类应该对扩展开放，对修改关闭。
    即在不修改类代码的情况下扩展它。

    个人补充：这是一个目标原则，没有告诉你怎么做才能“对扩展开放，对修改关闭”。一般需要先去实现 单一责任原则 和 依赖倒置原则。

    参考内容
        代码整洁之道：10.3
        Head First 设计模式：86 页

里氏替换原则（Liskov Substitution Principle，LSP）
    “Inheritance should ensure that any property proved about supertype objects also holds for subtype objects.” —— 继承
    必须确保超类所拥有的性质在子类中仍然成立。

    Robert C. Martin 把该原则简化为：“Subtypes must be substitutable for their base types”，即子类必须能够替换它们的基类。

    我们在开发中经常根据现实生活中的认知决定在代码中是否使用继承。比如生活中我们认为“男人”是一个“人”，所以想当然的就认为在代码中“男人”可以继
    承“人”。这是不严谨的，原因是生活中的继承关系和面向对象中的继承是不完全一致的概念。面向对象中继承所表示的 is-a 关系是针对 行为 而言的。

    生活和代码冲突的典型案例：
        正方形不是长方形
        鸵鸟不是鸟

    里氏替换原则告诉我们在代码中到底该不该用继承或者已经使用的继承是不是对的。如果不满足里式替换原则，就不能使用继承，而应该考虑使用其他方法
    进行组织。

    参考内容
        https://baike.baidu.com/item/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99
        https://www.iteye.com/blog/tonysmith-1105622
        https://blog.csdn.net/tjiyu/article/details/76551307
        https://refactoringguru.cn/didp/principles/solid-principles/lsp（链接可能没办法直接打开，可以从 模板方法 模式中找到入口）

    遵从了里式替换原则，也就遵从了开放关闭原则。

    关键字：继承、行为、替换。

接口隔离原则（Interface Segregation Principle，ISP）
    不应该强迫客户端（代码）去依赖它用不到的方法。这意味着相较于让所有的类都去实现单个庞大的接口（也叫胖接口），我们应该提供一组更小的、概念
    更具体的接口，让一个类实现一个或多个接口这样的接口。

    遵从了接口隔离原则，也就遵从了单一责任原则。

依赖倒置原则（Dependency Inversion Principle，DIP）
    应该依赖于抽象（即接口或抽象类），而不要依赖于具体（即具体类）。更准确的含义就是：应该在方法签名中通过接口和抽象类明确的声明依赖，而不应
    该在方法主体中隐式的依赖于具体类。
    不能让高层组件依赖底层组件，而且不管是高层还是底层组件，两者都应该依赖于抽象。

    相关概念：控制反转、依赖注入和容器的关系
        如果一个类 A 的功能实现需要借助于类 B，那么就称类 B 是类 A 的依赖，如果在类 A 的内部去实例化类 B，那么两者之间会出现较高的耦合，
        一旦类 B 出现了问题，类 A 也需要进行改造，如果这样的情况较多，每个类之间都有很多依赖，那么就会出现牵一发而动全身的情况，程序会极难
        维护，并且很容易出现问题。要解决这个问题，就要把 A 类对 B 类的控制权抽离出来，交给一个第三方去做，把控制权反转给第三方，就称作控制
        反转（IOC，Inversion Of Control）。
        控制反转常见的实现方式有：依赖注入、服务定位器和、依赖查找。依赖查找几乎没人用了，而服务定位器因违反了依赖倒置原则，也不推荐使用。
        很多控制反转的实现方式都有容器的概念，比如说依赖注入和服务定位器。在依赖注入中就称为依赖注入容器，在服务定位器中就称为服务定位容器。
        统称为 IOC 容器。
        依赖注入当下最优秀和常用的实现方式，它充分体现了依赖导致原则。由第三方（也称为 依赖注入容器）来控制依赖，把依赖通过构造函数、方法等方
        式注入到类 A 内，这样就极大程度的对类 A 和类 B 进行了解耦。

        请务必看：
            https://zhuanlan.zhihu.com/p/33492169
            https://juejin.im/entry/578b3b13c4c971005ee72181
            http://www.gouguoyin.cn/php/137.html

最少知识原则
    正式名称为 得墨忒耳定律 。类 C 的方法 f 应该只调用以下对象的方法：
        C
        由 C 的实体变量持有的对象
        作为参数传递给 f 的对象
        由 f 创建的对象（应该必须得有 new 才行）
    方法不应该调用由任何函数返回的对象的方法。换言之，只跟朋友交谈，不与陌生人交谈。

    参考内容
        代码整洁之道：6.3
        Head First 设计模式：265 页
        程序员修炼之道：112 页

多用组合，少用继承
    相对于继承，组合的弹性或者说可扩展性更好。

    有很多好的理由去使用继承而且也有很多好的理由去使用组合。如果你心里本能地去使用继承，尝试想想是否组合能够更好的建模你的问题。

    什么时候应该使用继承？这取决于你手上的问题，但这里有一份何时继承比组合更有意义的不错的清单：
        你的继承表示一个“是一个”关系而且不是一个“有一个”关系（人类->动物 vs 用户->用户详情）。
        你能够从基类复用代码（人类能够像所有动物一样移动）。
        你想要通过更改基类去对派生类进行全局更改（改变所有动物运动时的热量消耗）。

    参考内容
        深入PHP：8.2
        Head First 设计模式：23 页

针对接口编程，而不是针对实现编程
    针对接口编程实际上指的是针对抽象编程，既“针对超类型编程”，所以这里所说的“接口”从语法上来讲可以是接口或者抽象类。
    和依赖倒置原则几乎是一个意思。

好莱坞原则
    别调用（打电话给）我们，我们会调用（打电话给）你。
    高层组件会决定什么时候以及怎么样使用这些低层组件，低层组件不能直接调用高层组件，就可以防止依赖腐败（即互相依赖或者说依赖环）的出现。
    典型的实现方式就是通过在父类中定义并调用某个抽象方法，强制子类必须实现该抽象方法，比如模板方法模式和工厂方法模式。
    控制反转就是基于好莱坞原则的。

    参考内容
        Head First 设计模式：296 页

为交互对象之间的松耦合设计而努力
    松耦合能让我们建立有弹性的 OO 系统，能够应对变化。典型例子就是观察者模式。
