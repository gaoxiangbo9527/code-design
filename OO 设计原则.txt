封装变化
  找出应用中可能会变化的部分，把它们独立出来或者说封装起来，不要和那些不需要变化的部分混在一起。
  这样将来只需要改动此部分，而不会影响那些不需要变化的其他部分。系统的可维护性和扩展性会得到提高。

不要重复你自己（Don’t repeat yourself，DRY）

以上原则既适用于面向对象，也适用于面向过程；下面的原则只适用于面向对象。

单一责任原则（Single Responsibility Principle，SRP）
    也称 单一权责原则 。
    一个类应该只有责任 —— 被修改的理由。即要让每个类保持责任单一。

    实现方法
        将类的大函数拆分为小函数；为了减少小函数的参数，需要将参数提升为类的实体变量；类的实体变量一多，内聚性就在下降；为了保持内聚性，可以
        将部分函数以及这些函数所共享的实体变量独立出来；这样，大类就被拆分成了许多高内聚的、职责单一的类。

    参考内容
        代码整洁之道：10.2
        Head First 设计模式：339 页

开放/关闭原则（Open/Closed Principle，OCP）
    类应该对扩展开放，对修改关闭。
    即在不修改类代码的情况下扩展它。

    个人补充：这是一个目标原则，没有告诉你怎么做才能“对扩展开放，对修改关闭”。一般需要先去实现 单一责任原则 和 依赖倒置原则 。

    参考内容
        代码整洁之道：10.3
        Head First 设计模式：86 页

里氏替换原则（Liskov Substitution Principle，LSP）
    所有引用基类（父类）的地方必须能透明地使用其子类的对象

接口隔离原则（Interface Segregation Principle，ISP）

依赖倒置原则（Dependency Inversion Principle，DIP）
    应该依赖于抽象（即接口或抽象类），而不要依赖于具体（即具体类）。
    不能让高层组件依赖底层组件，而且不管是高层还是底层组件，两者都应该依赖于抽象。

针对接口编程，而不是针对实现编程
    针对接口编程实际上指的是针对抽象编程，既“针对超类型编程”，所以这里所说的“接口”从语法上来讲可以是接口或者抽象类。
    和依赖倒置原则几乎是一个意思。

最少知识原则
    正式名称为 得墨忒耳定律 。类 C 的方法 f 应该只调用以下对象的方法：
        C
        由 C 的实体变量持有的对象
        作为参数传递给 f 的对象
        由 f 创建的对象（应该必须得有 new 才行）
    方法不应该调用由任何函数返回的对象的方法。换言之，只跟朋友交谈，不与陌生人交谈。

    参考内容
        代码整洁之道：6.3
        Head First 设计模式：265 页
        程序员修炼之道：112 页

多用组合，少用继承
    相对于继承，组合的弹性或者说可扩展性更好。

为交互对象之间的松耦合设计而努力

好莱坞原则
    别调用（打电话给）我们，我们会调用（打电话给）你。

