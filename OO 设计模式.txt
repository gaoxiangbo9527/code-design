优秀的学习资源：
    https://refactoringguru.cn/design-patterns
        一份非常优秀的设计模式学习资源
    https://designpatternsphp.readthedocs.io/en/latest/README.html
        一份用 PHP 语言实现各种设计模式的例子的汇总。

基础设计模式
    创建型
        构建方法
            这不是一种模式，放在这里只是为了和工厂模式们做对比。
            就是一个调用了构造函数并返回对象的方法。例如：
                class Number {
                    private $value;

                    public function __construct($value) {
                        $this->value = $value;
                    }

                    public function next() {
                        return new Number ($this->value + 1);
                    }
                }

        静态构建方法
            这不是一种模式，放在这里只是为了和工厂模式们做对比。
            就是一个调用了构造函数并返回对象的静态方法。例如：
                class User {
                    private $id；
                    private $name;

                    public function __construct($id, $name) {
                        $this->id = $id;
                        $this->name = $name;
                    }

                    public static function load($id) {
                        list($id, $name) = DB::load_data('users', 'id', 'name');
                        $user = new User($id, $name);
                        return $user;
                    }
                }

        简单工厂
            描述了一个类， 它拥有一个包含大量条件语句的 构建方法 ，可根据构建方法的参数来选择对何种产品进行初始化并将其返回。

            严格来说并不算是一种设计模式，反而比较像是一种编程习惯。
            简单工厂的好处是，封装了可能会变化的部分（要创建的对象可能会增减），也可能会降低重复（可能有很多地方需要包含相同的创建逻辑）。

            简单工厂本身不是很强大，但是通过组合，可以把创建对象的任务委托给工厂对象。这时简单工厂已经非常接近策略模式了，如果真的需要切换简
            单工厂的对象，那其实就已经是策略模式了，只不过“算法”是用于创建对象的。

            简单工厂可以通过继承来扩展创建方法的行为，也方便实现测试替身，这些都是静态工厂做不到的，所以尽量不要用静态工厂。

        静态工厂
            就是“静态版”的简单工厂。和简单工厂的用途很类似。严格来说并不算是一种设计模式。

            静态工厂相对于简单工厂，唯一的好处就是不用实例化，但是缺点更多，所以尽量不要用静态工厂。

        工厂方法模式
            定义了一个创建对象的接口，但 由子类决定 要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

            由 子类做决定 这是工厂方法模式的核心，也是和其它创建型模式的最大的区别。

            如果工厂方法有指定参数，根据传入的参数的不同会创建不同的对象，这叫做“参数化工厂方法”。

        抽象工厂模式
            提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

            抽象工厂经常以工厂方法的方式实现。经常是抽象工厂（抽象类或接口）中定义一个家族的工厂方法，然后每个工厂方法对应着一类产品。

        生成器模式
            将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

        原型模式
            用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

            当创建给定的类的实例的过程很昂贵或者很复杂时，可以考虑使用原型模式。

        单例模式
            确保一个类只有一个实例，并为该实例提供一个全局访问点。

            被认为是一种反模式，从定义上就知道它做了两件事，违反了单一责任原则。建立尽可能少用单例模式。

            单例模式利用了静态方法来实现全局访问。但只要是全局访问本质上都是一样的，可能会绕过接口签名形成不好发现的依赖。使用单例模式的时候
            ，要先去获取单例对象，然后把单例对象传递给相应的接口；不要在接口实现中直接调用单例的静态 getInstance 方法。

            使用单例的客户端代码不好测试，因为一般测试替身是基于对象和继承机制实现的，而单例模式的构造方法是私有的，就无法通过继承得到测试替
            身，解决方案就是：要么不用单例模式，要么就绕过不测试，要么就进行特殊处理。其实 PHPUnit 默认的模拟机制是没有调用构造方法的，所
            以默认情况下可以模拟成功的，但是模拟出来的对象不会是唯一性的，这种情况对你来说到底合不合适，要自己根据具体情况决定。

    结构型
        装饰者模式
            动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

            包装对象，不改变接口，但在接口中增加新的行为和责任。

        适配器模式
            装一个类的接口转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。

            包装对象，改变接口，目的是转换接口或数据格式。

        外观模式
            提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

            包装一堆子系统对象，简化接口，解耦客户和子系统。

        组合模式
            允许将你的对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。

            组合，树形，一致的操作。

        代理模式
            为另一个对象提供一个替身或占位符以控制对这个对象的访问。

            代表，控制访问。

        桥接模式
            将抽象部分与它的实现部分分离，使它们可以独立地变化。

        享元模式
            运用共享技术有效地支持大量细粒度的对象。

    行为型
        策略模式
            定义算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

            组合，算法，切换。

        观察者模式
            定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。

        命令模式
            将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。

        模板方法模式
            在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

            继承，算法，框架。

        迭代器模式
            提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。

        状态模式
            允许对象在内部状态改变时改变它的行为，对象看起来好像个修改了它的类。
            结构上和策略模式是几乎一致，但出发点不同，状态之间是互相知道并且可以自动进行转移的。

            组合，状态，转移。

    其他
        依赖注入模式
            严格来说依赖注入不能说是一种模式，它的想法很简单，其实就是把依赖以方法参数的形式传入。非要和设计模式扯上关系的话，那也应该是依赖
            注入容器的实现算是一种模式。
            具体可以去看 PHP: The Right Way 中的第七章。

        空对象模式
            当你不能返回一个有意义的对象时，可以返回一个什么也不做的对象而不是 null ，这个什么也不做的对象即空对象。

            通过返回空对象，可以简化客户程序，因为不用再去执行“返回值是否是 null”的条件判断了，还可以降低测试的复杂度。空对象可以保证返回类
            型的一致性。

            严格来说空对象并不算是一种设计模式，应该称作是一种最佳实践。不过在很多设计模式中都会看到它的身影，所以经常被算作是一种设计模式。

        服务定位器模式
            被认为是一个反模式，不要用了。

            有两种实现方式：第一种是基于类的静态属性和静态方法的；第二种是基于对象的实例属性和实例方法的，一般还会配合单例模式实现定位器对象
            的唯一性。

            服务定位器模式的所有实现方式都必须先实现一个“服务”的容器，然后再实现存储“服务”的方法和查找（即定位）“服务”的方法。
            两种方法问题都很大，第一种方法的缺点和单例模式一样，会隐藏依赖关系，即依赖关系没有在方法签名中体现，违反了依赖倒置原则，也不好测
            试。如果第二种方法没有实现单例模式的话，我们要先实例化一个对象，这个对象实际上就是“容器”对象，然后把这个对象通过方法签名传入，最
            后你会发现，客户程序最后确实不依赖具体的“服务”了，但是却依赖于这个“容器”对象，没有本质变化。如果第二种方法有实现单例模式，那就
            和第一种方法非常接近了，缺点也是会隐藏依赖关系。

            可以考虑使用依赖注入（容器）替换掉服务定位器模式。

        注册模式
            个人认为这也是一种反模式，不要用了。

            就是一个通过字符串键名去存取对象的方法而已，有两种实现方式：第一种是基于类的静态属性和静态方法的；第二种是基于对象的实例属性和实
            例方法的，一般还会配合单例模式实现注册对象的唯一性。
            和服务定位器模式十分类似，一个是普通字符串形式的键，一个是类名字符串形式的键。
            缺陷可以参考服务定位器模式。

            可以考虑使用依赖注入（容器）替换掉注册模式。
复合模式
    MVC
    MVP
    MVVM

领域特定模式
    待补充

模式
    解释器模式
    访问者模式
    职责链模式
    中介者模式
